import { StageData } from '../models/stage-data.model';
import { OwlDOMData } from '../models/owlDOM-data.model';
import { CarouselSlideDirective } from '../carousel/carousel.module';
import { SlideModel } from '../models/slide.model';
import { Observable } from 'rxjs';
import { OwlOptions } from '../models/owl-options.model';
import { NavData, DotsData } from '../models/navigation-data.models';
import { OwlLogger } from './logger.service';
/**
 * Current state information and their tags.
 */
import * as ɵngcc0 from '@angular/core';
export declare class States {
    current: {};
    tags: {
        [key: string]: string[];
    };
}
/**
 * Enumeration for types.
 * @enum {String}
 */
export declare enum Type {
    Event = "event",
    State = "state"
}
/**
 * Enumeration for width.
 * @enum {String}
 */
export declare enum Width {
    Default = "default",
    Inner = "inner",
    Outer = "outer"
}
/**
 * Model for coords of .owl-stage
 */
export declare class Coords {
    x: number;
    y: number;
}
/**
 * Model for all current data of carousel
 */
export declare class CarouselCurrentData {
    owlDOMData: OwlDOMData;
    stageData: StageData;
    slidesData: SlideModel[];
    navData: NavData;
    dotsData: DotsData;
}
export declare class CarouselService {
    private logger;
    /**
   * Subject for passing data needed for managing View
   */
    private _viewSettingsShipper$;
    /**
   * Subject for notification when the carousel got initializes
   */
    private _initializedCarousel$;
    /**
   * Subject for notification when the carousel's settings start changinf
   */
    private _changeSettingsCarousel$;
    /**
   * Subject for notification when the carousel's settings have changed
   */
    private _changedSettingsCarousel$;
    /**
   * Subject for notification when the carousel starts translating or moving
   */
    private _translateCarousel$;
    /**
   * Subject for notification when the carousel stopped translating or moving
   */
    private _translatedCarousel$;
    /**
   * Subject for notification when the carousel's rebuilding caused by 'resize' event starts
   */
    private _resizeCarousel$;
    /**
   * Subject for notification  when the carousel's rebuilding caused by 'resize' event is ended
   */
    private _resizedCarousel$;
    /**
   * Subject for notification when the refresh of carousel starts
   */
    private _refreshCarousel$;
    /**
   * Subject for notification when the refresh of carousel is ended
   */
    private _refreshedCarousel$;
    /**
   * Subject for notification when the dragging of carousel starts
   */
    private _dragCarousel$;
    /**
   * Subject for notification when the dragging of carousel is ended
   */
    private _draggedCarousel$;
    /**
     * Current settings for the carousel.
     */
    settings: OwlOptions;
    /**
   * Initial data for setting classes to element .owl-carousel
   */
    owlDOMData: OwlDOMData;
    /**
   * Initial data of .owl-stage
   */
    stageData: StageData;
    /**
     *  Data of every slide
     */
    slidesData: SlideModel[];
    /**
     * Data of navigation block
     */
    navData: NavData;
    /**
     * Data of dots block
     */
    dotsData: DotsData;
    /**
     * Carousel width
     */
    private _width;
    /**
     * All real items.
     */
    private _items;
    /**
   * Array with width of every slide.
   */
    private _widths;
    /**
   * Currently suppressed events to prevent them from beeing retriggered.
   */
    private _supress;
    /**
     * References to the running plugins of this carousel.
     */
    private _plugins;
    /**
   * Absolute current position.
   */
    private _current;
    /**
   * All cloned items.
   */
    private _clones;
    /**
     * Merge values of all items.
     * @todo Maybe this could be part of a plugin.
     */
    private _mergers;
    /**
   * Animation speed in milliseconds.
   */
    private _speed;
    /**
   * Coordinates of all items in pixel.
   * @todo The name of this member is missleading.
   */
    private _coordinates;
    /**
   * Current breakpoint.
   * @todo Real media queries would be nice.
   */
    private _breakpoint;
    /**
     * Prefix for id of cloned slides
     */
    clonedIdPrefix: string;
    /**
     * Current options set by the caller including defaults.
     */
    _options: OwlOptions;
    /**
     * Invalidated parts within the update process.
     */
    private _invalidated;
    get invalidated(): any;
    /**
     * Current state information and their tags.
     */
    private _states;
    get states(): States;
    /**
     * Ordered list of workers for the update process.
   */
    private _pipe;
    constructor(logger: OwlLogger);
    /**
     * Makes _viewSettingsShipper$ Subject become Observable
     * @returns Observable of _viewSettingsShipper$ Subject
     */
    getViewCurSettings(): Observable<CarouselCurrentData>;
    /**
     * Makes _initializedCarousel$ Subject become Observable
     * @returns Observable of _initializedCarousel$ Subject
     */
    getInitializedState(): Observable<string>;
    /**
     * Makes _changeSettingsCarousel$ Subject become Observable
     * @returns Observable of _changeSettingsCarousel$ Subject
     */
    getChangeState(): Observable<any>;
    /**
     * Makes _changedSettingsCarousel$ Subject become Observable
     * @returns Observable of _changedSettingsCarousel$ Subject
     */
    getChangedState(): Observable<any>;
    /**
     * Makes _translateCarousel$ Subject become Observable
     * @returns Observable of _translateCarousel$ Subject
     */
    getTranslateState(): Observable<string>;
    /**
     * Makes _translatedCarousel$ Subject become Observable
     * @returns Observable of _translatedCarousel$ Subject
     */
    getTranslatedState(): Observable<string>;
    /**
     * Makes _resizeCarousel$ Subject become Observable
     * @returns Observable of _resizeCarousel$ Subject
     */
    getResizeState(): Observable<string>;
    /**
     * Makes _resizedCarousel$ Subject become Observable
     * @returns Observable of _resizedCarousel$ Subject
     */
    getResizedState(): Observable<string>;
    /**
     * Makes _refreshCarousel$ Subject become Observable
     * @returns Observable of _refreshCarousel$ Subject
     */
    getRefreshState(): Observable<string>;
    /**
     * Makes _refreshedCarousel$ Subject become Observable
     * @returns Observable of _refreshedCarousel$ Subject
     */
    getRefreshedState(): Observable<string>;
    /**
     * Makes _dragCarousel$ Subject become Observable
     * @returns Observable of _dragCarousel$ Subject
     */
    getDragState(): Observable<string>;
    /**
     * Makes _draggedCarousel$ Subject become Observable
     * @returns Observable of _draggedCarousel$ Subject
     */
    getDraggedState(): Observable<string>;
    /**
     * Setups custom options expanding default options
     * @param options custom options
     */
    setOptions(options: OwlOptions): void;
    /**
     * Checks whether user's option are set properly. Cheking is based on typings;
     * @param options options set by user
     * @param configOptions default options
     * @returns checked and modified (if it's needed) user's options
     *
     * Notes:
     * 	- if user set option with wrong type, it'll be written in console
     */
    private _validateOptions;
    /**
     * Checks the option `items` set by user and if it bigger than number of slides, the function returns number of slides
     * @param items option items set by user
     * @param skip_validateItems option `skip_validateItems` set by user
     * @returns right number of items
     */
    private _validateItems;
    /**
     * Set current width of carousel
     * @param width width of carousel Window
     */
    setCarouselWidth(width: number): void;
    /**
       * Setups the current settings.
       * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
       * @todo Support for media queries by using `matchMedia` would be nice.
       * @param carouselWidth width of carousel
       * @param slides array of slides
       * @param options options set by user
       */
    setup(carouselWidth: number, slides: CarouselSlideDirective[], options: OwlOptions): void;
    /**
     * Set options for current viewport
     */
    setOptionsForViewport(): void;
    /**
     * Initializes the carousel.
     * @param slides array of CarouselSlideDirective
     */
    initialize(slides: CarouselSlideDirective[]): void;
    /**
     * Sends all data needed for View
     */
    sendChanges(): void;
    /**
       * Updates option logic if necessery
       */
    private _optionsLogic;
    /**
     * Updates the view
     */
    update(): void;
    /**
       * Gets the width of the view.
       * @param [dimension=Width.Default] The dimension to return
       * @returns The width of the view in pixel.
       */
    width(dimension?: Width): number;
    /**
       * Refreshes the carousel primarily for adaptive purposes.
       */
    refresh(): void;
    /**
       * Checks window `resize` event.
       * @param curWidth width of .owl-carousel
       */
    onResize(curWidth: number): boolean;
    /**
       * Prepares data for dragging carousel. It starts after firing `touchstart` and `mousedown` events.
       * @todo Horizontal swipe threshold as option
       * @todo #261
       * @param event - The event arguments.
       * @returns stage - object with 'x' and 'y' coordinates of .owl-stage
       */
    prepareDragging(event: any): Coords;
    /**
     * Enters into a 'dragging' state
     */
    enterDragging(): void;
    /**
       * Defines new coords for .owl-stage while dragging it
       * @todo #261
       * @param event the event arguments.
       * @param dragData initial data got after starting dragging
       * @returns coords or false
       */
    defineNewCoordsDrag(event: any, dragData: any): boolean | Coords;
    /**
       * Finishes dragging of carousel when `touchend` and `mouseup` events fire.
       * @todo #261
       * @todo Threshold for click event
       * @param event the event arguments.
       * @param dragObj the object with dragging settings and states
       * @param clickAttacher function which attaches click handler to slide or its children elements in order to prevent event bubling
       */
    finishDragging(event: any, dragObj: any, clickAttacher: () => void): void;
    /**
       * Gets absolute position of the closest item for a coordinate.
       * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
       * @param coordinate The coordinate in pixel.
       * @param direction The direction to check for the closest item. Ether `left` or `right`.
       * @returns The absolute position of the closest item.
       */
    closest(coordinate: number, direction: string): number;
    /**
       * Animates the stage.
       * @todo #270
       * @param coordinate The coordinate in pixels.
       */
    animate(coordinate: number | number[]): void;
    /**
       * Checks whether the carousel is in a specific state or not.
       * @param state The state to check.
       * @returns The flag which indicates if the carousel is busy.
       */
    is(state: string): boolean;
    /**
       * Sets the absolute position of the current item.
       * @param position The new absolute position or nothing to leave it unchanged.
       * @returns The absolute position of the current item.
       */
    current(position?: number): number;
    /**
       * Invalidates the given part of the update routine.
       * @param part The part to invalidate.
       * @returns The invalidated parts.
       */
    invalidate(part: string): string[];
    /**
     * Resets the absolute position of the current item.
     * @param position the absolute position of the new item.
     */
    reset(position: number): void;
    /**
       * Normalizes an absolute or a relative position of an item.
       * @param position The absolute or relative position to normalize.
       * @param relative Whether the given position is relative or not.
       * @returns The normalized position.
       */
    normalize(position: number, relative?: boolean): number;
    /**
       * Converts an absolute position of an item into a relative one.
       * @param position The absolute position to convert.
       * @returns The converted position.
       */
    relative(position: number): number;
    /**
       * Gets the maximum position for the current item.
       * @param relative Whether to return an absolute position or a relative position.
       * @returns number of maximum position
       */
    maximum(relative?: boolean): number;
    /**
       * Gets the minimum position for the current item.
       * @param relative Whether to return an absolute position or a relative position.
       * @returns number of minimum position
       */
    minimum(relative?: boolean): number;
    /**
       * Gets an item at the specified relative position.
       * @param position The relative position of the item.
       * @returns The item at the given position or all items if no position was given.
       */
    items(position?: number): CarouselSlideDirective[];
    /**
       * Gets an item at the specified relative position.
       * @param position The relative position of the item.
       * @returns The item at the given position or all items if no position was given.
       */
    mergers(position: number): number | number[];
    /**
       * Gets the absolute positions of clones for an item.
       * @param position The relative position of the item.
       * @returns The absolute positions of clones for the item or all if no position was given.
       */
    clones(position?: number): number[];
    /**
       * Sets the current animation speed.
       * @param speed The animation speed in milliseconds or nothing to leave it unchanged.
       * @returns The current animation speed in milliseconds.
       */
    speed(speed?: number): number;
    /**
       * Gets the coordinate of an item.
       * @todo The name of this method is missleanding.
       * @param position The absolute position of the item within `minimum()` and `maximum()`.
       * @returns The coordinate of the item in pixel or all coordinates.
       */
    coordinates(position?: number): number | number[];
    /**
       * Calculates the speed for a translation.
       * @param from The absolute position of the start item.
       * @param to The absolute position of the target item.
       * @param factor [factor=undefined] - The time factor in milliseconds.
       * @returns The time in milliseconds for the translation.
       */
    private _duration;
    /**
       * Slides to the specified item.
       * @param position The position of the item.
       * @param speed The time in milliseconds for the transition.
       */
    to(position: number, speed: number | boolean): void;
    /**
       * Slides to the next item.
       * @param speed The time in milliseconds for the transition.
       */
    next(speed: number | boolean): void;
    /**
       * Slides to the previous item.
       * @param speed The time in milliseconds for the transition.
       */
    prev(speed: number | boolean): void;
    /**
       * Handles the end of an animation.
       * @param event - The event arguments.
       */
    onTransitionEnd(event?: any): boolean;
    /**
       * Gets viewport width.
       * @returns - The width in pixel.
       */
    private _viewport;
    /**
       * Sets _items
       * @param content The list of slides put into CarouselSlideDirectives.
       */
    setItems(content: CarouselSlideDirective[]): void;
    /**
     * Sets slidesData using this._items
     */
    private _defineSlidesData;
    /**
     * Sets current classes for slide
     * @param slide Slide of carousel
     * @returns object with names of css-classes which are keys and true/false values
     */
    setCurSlideClasses(slide: SlideModel): {
        [key: string]: boolean;
    };
    /**
       * Operators to calculate right-to-left and left-to-right.
       * @param a - The left side operand.
       * @param o - The operator.
       * @param b - The right side operand.
       * @returns true/false meaning right-to-left or left-to-right
       */
    private _op;
    /**
       * Triggers a public event.
       * @todo Remove `status`, `relatedTarget` should be used instead.
       * @param name The event name.
       * @param data The event data.
       * @param namespace The event namespace.
       * @param state The state which is associated with the event.
       * @param enter Indicates if the call enters the specified state or not.
       */
    private _trigger;
    /**
     * Enters a state.
     * @param name - The state name.
     */
    enter(name: string): void;
    /**
       * Leaves a state.
       * @param name - The state name.
       */
    leave(name: string): void;
    /**
       * Registers an event or state.
       * @param object - The event or state to register.
       */
    register(object: any): void;
    /**
       * Suppresses events.
       * @param events The events to suppress.
       */
    private _suppress;
    /**
       * Releases suppressed events.
       * @param events The events to release.
       */
    private _release;
    /**
       * Gets unified pointer coordinates from event.
       * @todo #261
       * @param event The `mousedown` or `touchstart` event.
       * @returns Object Coords which contains `x` and `y` coordinates of current pointer position.
       */
    pointer(event: any): Coords;
    /**
       * Determines if the input is a Number or something that can be coerced to a Number
       * @param number The input to be tested
       * @returns An indication if the input is a Number or can be coerced to a Number
       */
    private _isNumeric;
    /**
     * Determines whether value is number or boolean type
     * @param value The input to be tested
     * @returns An indication if the input is a Number or can be coerced to a Number, or Boolean
     */
    private _isNumberOrBoolean;
    /**
     * Determines whether value is number or string type
     * @param value The input to be tested
     * @returns An indication if the input is a Number or can be coerced to a Number, or String
     */
    private _isNumberOrString;
    /**
     * Determines whether value is number or string type
     * @param value The input to be tested
     * @returns An indication if the input is a Number or can be coerced to a Number, or String
     */
    private _isStringOrBoolean;
    /**
       * Gets the difference of two vectors.
       * @todo #261
       * @param first The first vector.
       * @param second- The second vector.
       * @returns The difference.
       */
    difference(first: Coords, second: Coords): Coords;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CarouselService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<CarouselService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJjYXJvdXNlbC5zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyakJBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhZ2VEYXRhIH0gZnJvbSAnLi4vbW9kZWxzL3N0YWdlLWRhdGEubW9kZWwnO1xyXG5pbXBvcnQgeyBPd2xET01EYXRhIH0gZnJvbSAnLi4vbW9kZWxzL293bERPTS1kYXRhLm1vZGVsJztcclxuaW1wb3J0IHsgQ2Fyb3VzZWxTbGlkZURpcmVjdGl2ZSB9IGZyb20gJy4uL2Nhcm91c2VsL2Nhcm91c2VsLm1vZHVsZSc7XHJcbmltcG9ydCB7IFNsaWRlTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvc2xpZGUubW9kZWwnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE93bE9wdGlvbnMgfSBmcm9tICcuLi9tb2RlbHMvb3dsLW9wdGlvbnMubW9kZWwnO1xyXG5pbXBvcnQgeyBOYXZEYXRhLCBEb3RzRGF0YSB9IGZyb20gJy4uL21vZGVscy9uYXZpZ2F0aW9uLWRhdGEubW9kZWxzJztcclxuaW1wb3J0IHsgT3dsTG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXIuc2VydmljZSc7XHJcbi8qKlxyXG4gKiBDdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIGFuZCB0aGVpciB0YWdzLlxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU3RhdGVzIHtcclxuICAgIGN1cnJlbnQ6IHt9O1xyXG4gICAgdGFnczoge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1tdO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogRW51bWVyYXRpb24gZm9yIHR5cGVzLlxyXG4gKiBAZW51bSB7U3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgZW51bSBUeXBlIHtcclxuICAgIEV2ZW50ID0gXCJldmVudFwiLFxyXG4gICAgU3RhdGUgPSBcInN0YXRlXCJcclxufVxyXG4vKipcclxuICogRW51bWVyYXRpb24gZm9yIHdpZHRoLlxyXG4gKiBAZW51bSB7U3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgZW51bSBXaWR0aCB7XHJcbiAgICBEZWZhdWx0ID0gXCJkZWZhdWx0XCIsXHJcbiAgICBJbm5lciA9IFwiaW5uZXJcIixcclxuICAgIE91dGVyID0gXCJvdXRlclwiXHJcbn1cclxuLyoqXHJcbiAqIE1vZGVsIGZvciBjb29yZHMgb2YgLm93bC1zdGFnZVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ29vcmRzIHtcclxuICAgIHg6IG51bWJlcjtcclxuICAgIHk6IG51bWJlcjtcclxufVxyXG4vKipcclxuICogTW9kZWwgZm9yIGFsbCBjdXJyZW50IGRhdGEgb2YgY2Fyb3VzZWxcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENhcm91c2VsQ3VycmVudERhdGEge1xyXG4gICAgb3dsRE9NRGF0YTogT3dsRE9NRGF0YTtcclxuICAgIHN0YWdlRGF0YTogU3RhZ2VEYXRhO1xyXG4gICAgc2xpZGVzRGF0YTogU2xpZGVNb2RlbFtdO1xyXG4gICAgbmF2RGF0YTogTmF2RGF0YTtcclxuICAgIGRvdHNEYXRhOiBEb3RzRGF0YTtcclxufVxyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBDYXJvdXNlbFNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSBsb2dnZXI7XHJcbiAgICAvKipcclxuICAgKiBTdWJqZWN0IGZvciBwYXNzaW5nIGRhdGEgbmVlZGVkIGZvciBtYW5hZ2luZyBWaWV3XHJcbiAgICovXHJcbiAgICBwcml2YXRlIF92aWV3U2V0dGluZ3NTaGlwcGVyJDtcclxuICAgIC8qKlxyXG4gICAqIFN1YmplY3QgZm9yIG5vdGlmaWNhdGlvbiB3aGVuIHRoZSBjYXJvdXNlbCBnb3QgaW5pdGlhbGl6ZXNcclxuICAgKi9cclxuICAgIHByaXZhdGUgX2luaXRpYWxpemVkQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICogU3ViamVjdCBmb3Igbm90aWZpY2F0aW9uIHdoZW4gdGhlIGNhcm91c2VsJ3Mgc2V0dGluZ3Mgc3RhcnQgY2hhbmdpbmZcclxuICAgKi9cclxuICAgIHByaXZhdGUgX2NoYW5nZVNldHRpbmdzQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICogU3ViamVjdCBmb3Igbm90aWZpY2F0aW9uIHdoZW4gdGhlIGNhcm91c2VsJ3Mgc2V0dGluZ3MgaGF2ZSBjaGFuZ2VkXHJcbiAgICovXHJcbiAgICBwcml2YXRlIF9jaGFuZ2VkU2V0dGluZ3NDYXJvdXNlbCQ7XHJcbiAgICAvKipcclxuICAgKiBTdWJqZWN0IGZvciBub3RpZmljYXRpb24gd2hlbiB0aGUgY2Fyb3VzZWwgc3RhcnRzIHRyYW5zbGF0aW5nIG9yIG1vdmluZ1xyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfdHJhbnNsYXRlQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICogU3ViamVjdCBmb3Igbm90aWZpY2F0aW9uIHdoZW4gdGhlIGNhcm91c2VsIHN0b3BwZWQgdHJhbnNsYXRpbmcgb3IgbW92aW5nXHJcbiAgICovXHJcbiAgICBwcml2YXRlIF90cmFuc2xhdGVkQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICogU3ViamVjdCBmb3Igbm90aWZpY2F0aW9uIHdoZW4gdGhlIGNhcm91c2VsJ3MgcmVidWlsZGluZyBjYXVzZWQgYnkgJ3Jlc2l6ZScgZXZlbnQgc3RhcnRzXHJcbiAgICovXHJcbiAgICBwcml2YXRlIF9yZXNpemVDYXJvdXNlbCQ7XHJcbiAgICAvKipcclxuICAgKiBTdWJqZWN0IGZvciBub3RpZmljYXRpb24gIHdoZW4gdGhlIGNhcm91c2VsJ3MgcmVidWlsZGluZyBjYXVzZWQgYnkgJ3Jlc2l6ZScgZXZlbnQgaXMgZW5kZWRcclxuICAgKi9cclxuICAgIHByaXZhdGUgX3Jlc2l6ZWRDYXJvdXNlbCQ7XHJcbiAgICAvKipcclxuICAgKiBTdWJqZWN0IGZvciBub3RpZmljYXRpb24gd2hlbiB0aGUgcmVmcmVzaCBvZiBjYXJvdXNlbCBzdGFydHNcclxuICAgKi9cclxuICAgIHByaXZhdGUgX3JlZnJlc2hDYXJvdXNlbCQ7XHJcbiAgICAvKipcclxuICAgKiBTdWJqZWN0IGZvciBub3RpZmljYXRpb24gd2hlbiB0aGUgcmVmcmVzaCBvZiBjYXJvdXNlbCBpcyBlbmRlZFxyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfcmVmcmVzaGVkQ2Fyb3VzZWwkO1xyXG4gICAgLyoqXHJcbiAgICogU3ViamVjdCBmb3Igbm90aWZpY2F0aW9uIHdoZW4gdGhlIGRyYWdnaW5nIG9mIGNhcm91c2VsIHN0YXJ0c1xyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfZHJhZ0Nhcm91c2VsJDtcclxuICAgIC8qKlxyXG4gICAqIFN1YmplY3QgZm9yIG5vdGlmaWNhdGlvbiB3aGVuIHRoZSBkcmFnZ2luZyBvZiBjYXJvdXNlbCBpcyBlbmRlZFxyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfZHJhZ2dlZENhcm91c2VsJDtcclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBzZXR0aW5ncyBmb3IgdGhlIGNhcm91c2VsLlxyXG4gICAgICovXHJcbiAgICBzZXR0aW5nczogT3dsT3B0aW9ucztcclxuICAgIC8qKlxyXG4gICAqIEluaXRpYWwgZGF0YSBmb3Igc2V0dGluZyBjbGFzc2VzIHRvIGVsZW1lbnQgLm93bC1jYXJvdXNlbFxyXG4gICAqL1xyXG4gICAgb3dsRE9NRGF0YTogT3dsRE9NRGF0YTtcclxuICAgIC8qKlxyXG4gICAqIEluaXRpYWwgZGF0YSBvZiAub3dsLXN0YWdlXHJcbiAgICovXHJcbiAgICBzdGFnZURhdGE6IFN0YWdlRGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogIERhdGEgb2YgZXZlcnkgc2xpZGVcclxuICAgICAqL1xyXG4gICAgc2xpZGVzRGF0YTogU2xpZGVNb2RlbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEYXRhIG9mIG5hdmlnYXRpb24gYmxvY2tcclxuICAgICAqL1xyXG4gICAgbmF2RGF0YTogTmF2RGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogRGF0YSBvZiBkb3RzIGJsb2NrXHJcbiAgICAgKi9cclxuICAgIGRvdHNEYXRhOiBEb3RzRGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogQ2Fyb3VzZWwgd2lkdGhcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfd2lkdGg7XHJcbiAgICAvKipcclxuICAgICAqIEFsbCByZWFsIGl0ZW1zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pdGVtcztcclxuICAgIC8qKlxyXG4gICAqIEFycmF5IHdpdGggd2lkdGggb2YgZXZlcnkgc2xpZGUuXHJcbiAgICovXHJcbiAgICBwcml2YXRlIF93aWR0aHM7XHJcbiAgICAvKipcclxuICAgKiBDdXJyZW50bHkgc3VwcHJlc3NlZCBldmVudHMgdG8gcHJldmVudCB0aGVtIGZyb20gYmVlaW5nIHJldHJpZ2dlcmVkLlxyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfc3VwcmVzcztcclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlcyB0byB0aGUgcnVubmluZyBwbHVnaW5zIG9mIHRoaXMgY2Fyb3VzZWwuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3BsdWdpbnM7XHJcbiAgICAvKipcclxuICAgKiBBYnNvbHV0ZSBjdXJyZW50IHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfY3VycmVudDtcclxuICAgIC8qKlxyXG4gICAqIEFsbCBjbG9uZWQgaXRlbXMuXHJcbiAgICovXHJcbiAgICBwcml2YXRlIF9jbG9uZXM7XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlIHZhbHVlcyBvZiBhbGwgaXRlbXMuXHJcbiAgICAgKiBAdG9kbyBNYXliZSB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgYSBwbHVnaW4uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX21lcmdlcnM7XHJcbiAgICAvKipcclxuICAgKiBBbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAqL1xyXG4gICAgcHJpdmF0ZSBfc3BlZWQ7XHJcbiAgICAvKipcclxuICAgKiBDb29yZGluYXRlcyBvZiBhbGwgaXRlbXMgaW4gcGl4ZWwuXHJcbiAgICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZW1iZXIgaXMgbWlzc2xlYWRpbmcuXHJcbiAgICovXHJcbiAgICBwcml2YXRlIF9jb29yZGluYXRlcztcclxuICAgIC8qKlxyXG4gICAqIEN1cnJlbnQgYnJlYWtwb2ludC5cclxuICAgKiBAdG9kbyBSZWFsIG1lZGlhIHF1ZXJpZXMgd291bGQgYmUgbmljZS5cclxuICAgKi9cclxuICAgIHByaXZhdGUgX2JyZWFrcG9pbnQ7XHJcbiAgICAvKipcclxuICAgICAqIFByZWZpeCBmb3IgaWQgb2YgY2xvbmVkIHNsaWRlc1xyXG4gICAgICovXHJcbiAgICBjbG9uZWRJZFByZWZpeDogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IG9wdGlvbnMgc2V0IGJ5IHRoZSBjYWxsZXIgaW5jbHVkaW5nIGRlZmF1bHRzLlxyXG4gICAgICovXHJcbiAgICBfb3B0aW9uczogT3dsT3B0aW9ucztcclxuICAgIC8qKlxyXG4gICAgICogSW52YWxpZGF0ZWQgcGFydHMgd2l0aGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaW52YWxpZGF0ZWQ7XHJcbiAgICBnZXQgaW52YWxpZGF0ZWQoKTogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIGFuZCB0aGVpciB0YWdzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9zdGF0ZXM7XHJcbiAgICBnZXQgc3RhdGVzKCk6IFN0YXRlcztcclxuICAgIC8qKlxyXG4gICAgICogT3JkZXJlZCBsaXN0IG9mIHdvcmtlcnMgZm9yIHRoZSB1cGRhdGUgcHJvY2Vzcy5cclxuICAgKi9cclxuICAgIHByaXZhdGUgX3BpcGU7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb2dnZXI6IE93bExvZ2dlcik7XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIF92aWV3U2V0dGluZ3NTaGlwcGVyJCBTdWJqZWN0IGJlY29tZSBPYnNlcnZhYmxlXHJcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIF92aWV3U2V0dGluZ3NTaGlwcGVyJCBTdWJqZWN0XHJcbiAgICAgKi9cclxuICAgIGdldFZpZXdDdXJTZXR0aW5ncygpOiBPYnNlcnZhYmxlPENhcm91c2VsQ3VycmVudERhdGE+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBfaW5pdGlhbGl6ZWRDYXJvdXNlbCQgU3ViamVjdCBiZWNvbWUgT2JzZXJ2YWJsZVxyXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBfaW5pdGlhbGl6ZWRDYXJvdXNlbCQgU3ViamVjdFxyXG4gICAgICovXHJcbiAgICBnZXRJbml0aWFsaXplZFN0YXRlKCk6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgX2NoYW5nZVNldHRpbmdzQ2Fyb3VzZWwkIFN1YmplY3QgYmVjb21lIE9ic2VydmFibGVcclxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgX2NoYW5nZVNldHRpbmdzQ2Fyb3VzZWwkIFN1YmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhbmdlU3RhdGUoKTogT2JzZXJ2YWJsZTxhbnk+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBfY2hhbmdlZFNldHRpbmdzQ2Fyb3VzZWwkIFN1YmplY3QgYmVjb21lIE9ic2VydmFibGVcclxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgX2NoYW5nZWRTZXR0aW5nc0Nhcm91c2VsJCBTdWJqZWN0XHJcbiAgICAgKi9cclxuICAgIGdldENoYW5nZWRTdGF0ZSgpOiBPYnNlcnZhYmxlPGFueT47XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIF90cmFuc2xhdGVDYXJvdXNlbCQgU3ViamVjdCBiZWNvbWUgT2JzZXJ2YWJsZVxyXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBfdHJhbnNsYXRlQ2Fyb3VzZWwkIFN1YmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNsYXRlU3RhdGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBfdHJhbnNsYXRlZENhcm91c2VsJCBTdWJqZWN0IGJlY29tZSBPYnNlcnZhYmxlXHJcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIF90cmFuc2xhdGVkQ2Fyb3VzZWwkIFN1YmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNsYXRlZFN0YXRlKCk6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgX3Jlc2l6ZUNhcm91c2VsJCBTdWJqZWN0IGJlY29tZSBPYnNlcnZhYmxlXHJcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIF9yZXNpemVDYXJvdXNlbCQgU3ViamVjdFxyXG4gICAgICovXHJcbiAgICBnZXRSZXNpemVTdGF0ZSgpOiBPYnNlcnZhYmxlPHN0cmluZz47XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIF9yZXNpemVkQ2Fyb3VzZWwkIFN1YmplY3QgYmVjb21lIE9ic2VydmFibGVcclxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgX3Jlc2l6ZWRDYXJvdXNlbCQgU3ViamVjdFxyXG4gICAgICovXHJcbiAgICBnZXRSZXNpemVkU3RhdGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBfcmVmcmVzaENhcm91c2VsJCBTdWJqZWN0IGJlY29tZSBPYnNlcnZhYmxlXHJcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIF9yZWZyZXNoQ2Fyb3VzZWwkIFN1YmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0UmVmcmVzaFN0YXRlKCk6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgX3JlZnJlc2hlZENhcm91c2VsJCBTdWJqZWN0IGJlY29tZSBPYnNlcnZhYmxlXHJcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIF9yZWZyZXNoZWRDYXJvdXNlbCQgU3ViamVjdFxyXG4gICAgICovXHJcbiAgICBnZXRSZWZyZXNoZWRTdGF0ZSgpOiBPYnNlcnZhYmxlPHN0cmluZz47XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIF9kcmFnQ2Fyb3VzZWwkIFN1YmplY3QgYmVjb21lIE9ic2VydmFibGVcclxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgX2RyYWdDYXJvdXNlbCQgU3ViamVjdFxyXG4gICAgICovXHJcbiAgICBnZXREcmFnU3RhdGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBfZHJhZ2dlZENhcm91c2VsJCBTdWJqZWN0IGJlY29tZSBPYnNlcnZhYmxlXHJcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIF9kcmFnZ2VkQ2Fyb3VzZWwkIFN1YmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0RHJhZ2dlZFN0YXRlKCk6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIC8qKlxyXG4gICAgICogU2V0dXBzIGN1c3RvbSBvcHRpb25zIGV4cGFuZGluZyBkZWZhdWx0IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIGN1c3RvbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHNldE9wdGlvbnMob3B0aW9uczogT3dsT3B0aW9ucyk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHVzZXIncyBvcHRpb24gYXJlIHNldCBwcm9wZXJseS4gQ2hla2luZyBpcyBiYXNlZCBvbiB0eXBpbmdzO1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBzZXQgYnkgdXNlclxyXG4gICAgICogQHBhcmFtIGNvbmZpZ09wdGlvbnMgZGVmYXVsdCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyBjaGVja2VkIGFuZCBtb2RpZmllZCAoaWYgaXQncyBuZWVkZWQpIHVzZXIncyBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogTm90ZXM6XHJcbiAgICAgKiBcdC0gaWYgdXNlciBzZXQgb3B0aW9uIHdpdGggd3JvbmcgdHlwZSwgaXQnbGwgYmUgd3JpdHRlbiBpbiBjb25zb2xlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3ZhbGlkYXRlT3B0aW9ucztcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoZSBvcHRpb24gYGl0ZW1zYCBzZXQgYnkgdXNlciBhbmQgaWYgaXQgYmlnZ2VyIHRoYW4gbnVtYmVyIG9mIHNsaWRlcywgdGhlIGZ1bmN0aW9uIHJldHVybnMgbnVtYmVyIG9mIHNsaWRlc1xyXG4gICAgICogQHBhcmFtIGl0ZW1zIG9wdGlvbiBpdGVtcyBzZXQgYnkgdXNlclxyXG4gICAgICogQHBhcmFtIHNraXBfdmFsaWRhdGVJdGVtcyBvcHRpb24gYHNraXBfdmFsaWRhdGVJdGVtc2Agc2V0IGJ5IHVzZXJcclxuICAgICAqIEByZXR1cm5zIHJpZ2h0IG51bWJlciBvZiBpdGVtc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF92YWxpZGF0ZUl0ZW1zO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY3VycmVudCB3aWR0aCBvZiBjYXJvdXNlbFxyXG4gICAgICogQHBhcmFtIHdpZHRoIHdpZHRoIG9mIGNhcm91c2VsIFdpbmRvd1xyXG4gICAgICovXHJcbiAgICBzZXRDYXJvdXNlbFdpZHRoKHdpZHRoOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIFNldHVwcyB0aGUgY3VycmVudCBzZXR0aW5ncy5cclxuICAgICAgICogQHRvZG8gUmVtb3ZlIHJlc3BvbnNpdmUgY2xhc3Nlcy4gV2h5IHNob3VsZCBhZGFwdGl2ZSBkZXNpZ25zIGJlIGJyb3VnaHQgaW50byBJRTg/XHJcbiAgICAgICAqIEB0b2RvIFN1cHBvcnQgZm9yIG1lZGlhIHF1ZXJpZXMgYnkgdXNpbmcgYG1hdGNoTWVkaWFgIHdvdWxkIGJlIG5pY2UuXHJcbiAgICAgICAqIEBwYXJhbSBjYXJvdXNlbFdpZHRoIHdpZHRoIG9mIGNhcm91c2VsXHJcbiAgICAgICAqIEBwYXJhbSBzbGlkZXMgYXJyYXkgb2Ygc2xpZGVzXHJcbiAgICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgc2V0IGJ5IHVzZXJcclxuICAgICAgICovXHJcbiAgICBzZXR1cChjYXJvdXNlbFdpZHRoOiBudW1iZXIsIHNsaWRlczogQ2Fyb3VzZWxTbGlkZURpcmVjdGl2ZVtdLCBvcHRpb25zOiBPd2xPcHRpb25zKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9wdGlvbnMgZm9yIGN1cnJlbnQgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0T3B0aW9uc0ZvclZpZXdwb3J0KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjYXJvdXNlbC5cclxuICAgICAqIEBwYXJhbSBzbGlkZXMgYXJyYXkgb2YgQ2Fyb3VzZWxTbGlkZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplKHNsaWRlczogQ2Fyb3VzZWxTbGlkZURpcmVjdGl2ZVtdKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYWxsIGRhdGEgbmVlZGVkIGZvciBWaWV3XHJcbiAgICAgKi9cclxuICAgIHNlbmRDaGFuZ2VzKCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAgICogVXBkYXRlcyBvcHRpb24gbG9naWMgaWYgbmVjZXNzZXJ5XHJcbiAgICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfb3B0aW9uc0xvZ2ljO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3LlxyXG4gICAgICAgKiBAcGFyYW0gW2RpbWVuc2lvbj1XaWR0aC5EZWZhdWx0XSBUaGUgZGltZW5zaW9uIHRvIHJldHVyblxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgd2lkdGggb2YgdGhlIHZpZXcgaW4gcGl4ZWwuXHJcbiAgICAgICAqL1xyXG4gICAgd2lkdGgoZGltZW5zaW9uPzogV2lkdGgpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAgICogUmVmcmVzaGVzIHRoZSBjYXJvdXNlbCBwcmltYXJpbHkgZm9yIGFkYXB0aXZlIHB1cnBvc2VzLlxyXG4gICAgICAgKi9cclxuICAgIHJlZnJlc2goKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICAgKiBDaGVja3Mgd2luZG93IGByZXNpemVgIGV2ZW50LlxyXG4gICAgICAgKiBAcGFyYW0gY3VyV2lkdGggd2lkdGggb2YgLm93bC1jYXJvdXNlbFxyXG4gICAgICAgKi9cclxuICAgIG9uUmVzaXplKGN1cldpZHRoOiBudW1iZXIpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIFByZXBhcmVzIGRhdGEgZm9yIGRyYWdnaW5nIGNhcm91c2VsLiBJdCBzdGFydHMgYWZ0ZXIgZmlyaW5nIGB0b3VjaHN0YXJ0YCBhbmQgYG1vdXNlZG93bmAgZXZlbnRzLlxyXG4gICAgICAgKiBAdG9kbyBIb3Jpem9udGFsIHN3aXBlIHRocmVzaG9sZCBhcyBvcHRpb25cclxuICAgICAgICogQHRvZG8gIzI2MVxyXG4gICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxyXG4gICAgICAgKiBAcmV0dXJucyBzdGFnZSAtIG9iamVjdCB3aXRoICd4JyBhbmQgJ3knIGNvb3JkaW5hdGVzIG9mIC5vd2wtc3RhZ2VcclxuICAgICAgICovXHJcbiAgICBwcmVwYXJlRHJhZ2dpbmcoZXZlbnQ6IGFueSk6IENvb3JkcztcclxuICAgIC8qKlxyXG4gICAgICogRW50ZXJzIGludG8gYSAnZHJhZ2dpbmcnIHN0YXRlXHJcbiAgICAgKi9cclxuICAgIGVudGVyRHJhZ2dpbmcoKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICAgKiBEZWZpbmVzIG5ldyBjb29yZHMgZm9yIC5vd2wtc3RhZ2Ugd2hpbGUgZHJhZ2dpbmcgaXRcclxuICAgICAgICogQHRvZG8gIzI2MVxyXG4gICAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IGFyZ3VtZW50cy5cclxuICAgICAgICogQHBhcmFtIGRyYWdEYXRhIGluaXRpYWwgZGF0YSBnb3QgYWZ0ZXIgc3RhcnRpbmcgZHJhZ2dpbmdcclxuICAgICAgICogQHJldHVybnMgY29vcmRzIG9yIGZhbHNlXHJcbiAgICAgICAqL1xyXG4gICAgZGVmaW5lTmV3Q29vcmRzRHJhZyhldmVudDogYW55LCBkcmFnRGF0YTogYW55KTogYm9vbGVhbiB8IENvb3JkcztcclxuICAgIC8qKlxyXG4gICAgICAgKiBGaW5pc2hlcyBkcmFnZ2luZyBvZiBjYXJvdXNlbCB3aGVuIGB0b3VjaGVuZGAgYW5kIGBtb3VzZXVwYCBldmVudHMgZmlyZS5cclxuICAgICAgICogQHRvZG8gIzI2MVxyXG4gICAgICAgKiBAdG9kbyBUaHJlc2hvbGQgZm9yIGNsaWNrIGV2ZW50XHJcbiAgICAgICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgYXJndW1lbnRzLlxyXG4gICAgICAgKiBAcGFyYW0gZHJhZ09iaiB0aGUgb2JqZWN0IHdpdGggZHJhZ2dpbmcgc2V0dGluZ3MgYW5kIHN0YXRlc1xyXG4gICAgICAgKiBAcGFyYW0gY2xpY2tBdHRhY2hlciBmdW5jdGlvbiB3aGljaCBhdHRhY2hlcyBjbGljayBoYW5kbGVyIHRvIHNsaWRlIG9yIGl0cyBjaGlsZHJlbiBlbGVtZW50cyBpbiBvcmRlciB0byBwcmV2ZW50IGV2ZW50IGJ1YmxpbmdcclxuICAgICAgICovXHJcbiAgICBmaW5pc2hEcmFnZ2luZyhldmVudDogYW55LCBkcmFnT2JqOiBhbnksIGNsaWNrQXR0YWNoZXI6ICgpID0+IHZvaWQpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIEdldHMgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbSBmb3IgYSBjb29yZGluYXRlLlxyXG4gICAgICAgKiBAdG9kbyBTZXR0aW5nIGBmcmVlRHJhZ2AgbWFrZXMgYGNsb3Nlc3RgIG5vdCByZXVzYWJsZS4gU2VlICMxNjUuXHJcbiAgICAgICAqIEBwYXJhbSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIGluIHBpeGVsLlxyXG4gICAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBjbG9zZXN0IGl0ZW0uIEV0aGVyIGBsZWZ0YCBvciBgcmlnaHRgLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cclxuICAgICAgICovXHJcbiAgICBjbG9zZXN0KGNvb3JkaW5hdGU6IG51bWJlciwgZGlyZWN0aW9uOiBzdHJpbmcpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAgICogQW5pbWF0ZXMgdGhlIHN0YWdlLlxyXG4gICAgICAgKiBAdG9kbyAjMjcwXHJcbiAgICAgICAqIEBwYXJhbSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIGluIHBpeGVscy5cclxuICAgICAgICovXHJcbiAgICBhbmltYXRlKGNvb3JkaW5hdGU6IG51bWJlciB8IG51bWJlcltdKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgaW4gYSBzcGVjaWZpYyBzdGF0ZSBvciBub3QuXHJcbiAgICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdG8gY2hlY2suXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgY2Fyb3VzZWwgaXMgYnVzeS5cclxuICAgICAgICovXHJcbiAgICBpcyhzdGF0ZTogc3RyaW5nKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICAgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxyXG4gICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBhYnNvbHV0ZSBwb3NpdGlvbiBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cclxuICAgICAgICogQHJldHVybnMgVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXHJcbiAgICAgICAqL1xyXG4gICAgY3VycmVudChwb3NpdGlvbj86IG51bWJlcik6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICAgKiBJbnZhbGlkYXRlcyB0aGUgZ2l2ZW4gcGFydCBvZiB0aGUgdXBkYXRlIHJvdXRpbmUuXHJcbiAgICAgICAqIEBwYXJhbSBwYXJ0IFRoZSBwYXJ0IHRvIGludmFsaWRhdGUuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBpbnZhbGlkYXRlZCBwYXJ0cy5cclxuICAgICAgICovXHJcbiAgICBpbnZhbGlkYXRlKHBhcnQ6IHN0cmluZyk6IHN0cmluZ1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBuZXcgaXRlbS5cclxuICAgICAqL1xyXG4gICAgcmVzZXQocG9zaXRpb246IG51bWJlcik6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAgICogTm9ybWFsaXplcyBhbiBhYnNvbHV0ZSBvciBhIHJlbGF0aXZlIHBvc2l0aW9uIG9mIGFuIGl0ZW0uXHJcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gbm9ybWFsaXplLlxyXG4gICAgICAgKiBAcGFyYW0gcmVsYXRpdmUgV2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcmVsYXRpdmUgb3Igbm90LlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBwb3NpdGlvbi5cclxuICAgICAgICovXHJcbiAgICBub3JtYWxpemUocG9zaXRpb246IG51bWJlciwgcmVsYXRpdmU/OiBib29sZWFuKTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIENvbnZlcnRzIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mIGFuIGl0ZW0gaW50byBhIHJlbGF0aXZlIG9uZS5cclxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB0byBjb252ZXJ0LlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHBvc2l0aW9uLlxyXG4gICAgICAgKi9cclxuICAgIHJlbGF0aXZlKHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAgICogR2V0cyB0aGUgbWF4aW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cclxuICAgICAgICogQHBhcmFtIHJlbGF0aXZlIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXHJcbiAgICAgICAqIEByZXR1cm5zIG51bWJlciBvZiBtYXhpbXVtIHBvc2l0aW9uXHJcbiAgICAgICAqL1xyXG4gICAgbWF4aW11bShyZWxhdGl2ZT86IGJvb2xlYW4pOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAgICogR2V0cyB0aGUgbWluaW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cclxuICAgICAgICogQHBhcmFtIHJlbGF0aXZlIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXHJcbiAgICAgICAqIEByZXR1cm5zIG51bWJlciBvZiBtaW5pbXVtIHBvc2l0aW9uXHJcbiAgICAgICAqL1xyXG4gICAgbWluaW11bShyZWxhdGl2ZT86IGJvb2xlYW4pOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAgICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXHJcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxyXG4gICAgICAgKi9cclxuICAgIGl0ZW1zKHBvc2l0aW9uPzogbnVtYmVyKTogQ2Fyb3VzZWxTbGlkZURpcmVjdGl2ZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxyXG4gICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cclxuICAgICAgICovXHJcbiAgICBtZXJnZXJzKHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIgfCBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICAgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciBhbiBpdGVtLlxyXG4gICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGNsb25lcyBmb3IgdGhlIGl0ZW0gb3IgYWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cclxuICAgICAgICovXHJcbiAgICBjbG9uZXMocG9zaXRpb24/OiBudW1iZXIpOiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzcGVlZC5cclxuICAgICAgICogQHBhcmFtIHNwZWVkIFRoZSBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxyXG4gICAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgKi9cclxuICAgIHNwZWVkKHNwZWVkPzogbnVtYmVyKTogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIEdldHMgdGhlIGNvb3JkaW5hdGUgb2YgYW4gaXRlbS5cclxuICAgICAgICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgbWlzc2xlYW5kaW5nLlxyXG4gICAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHdpdGhpbiBgbWluaW11bSgpYCBhbmQgYG1heGltdW0oKWAuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSBjb29yZGluYXRlIG9mIHRoZSBpdGVtIGluIHBpeGVsIG9yIGFsbCBjb29yZGluYXRlcy5cclxuICAgICAgICovXHJcbiAgICBjb29yZGluYXRlcyhwb3NpdGlvbj86IG51bWJlcik6IG51bWJlciB8IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHNwZWVkIGZvciBhIHRyYW5zbGF0aW9uLlxyXG4gICAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IGl0ZW0uXHJcbiAgICAgICAqIEBwYXJhbSB0byBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBpdGVtLlxyXG4gICAgICAgKiBAcGFyYW0gZmFjdG9yIFtmYWN0b3I9dW5kZWZpbmVkXSAtIFRoZSB0aW1lIGZhY3RvciBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgICAqIEByZXR1cm5zIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICAgKi9cclxuICAgIHByaXZhdGUgX2R1cmF0aW9uO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0uXHJcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAqIEBwYXJhbSBzcGVlZCBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxyXG4gICAgICAgKi9cclxuICAgIHRvKHBvc2l0aW9uOiBudW1iZXIsIHNwZWVkOiBudW1iZXIgfCBib29sZWFuKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICAgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbS5cclxuICAgICAgICogQHBhcmFtIHNwZWVkIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXHJcbiAgICAgICAqL1xyXG4gICAgbmV4dChzcGVlZDogbnVtYmVyIHwgYm9vbGVhbik6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAgICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxyXG4gICAgICAgKiBAcGFyYW0gc3BlZWQgVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cclxuICAgICAgICovXHJcbiAgICBwcmV2KHNwZWVkOiBudW1iZXIgfCBib29sZWFuKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICAgKiBIYW5kbGVzIHRoZSBlbmQgb2YgYW4gYW5pbWF0aW9uLlxyXG4gICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxyXG4gICAgICAgKi9cclxuICAgIG9uVHJhbnNpdGlvbkVuZChldmVudD86IGFueSk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAgICogR2V0cyB2aWV3cG9ydCB3aWR0aC5cclxuICAgICAgICogQHJldHVybnMgLSBUaGUgd2lkdGggaW4gcGl4ZWwuXHJcbiAgICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfdmlld3BvcnQ7XHJcbiAgICAvKipcclxuICAgICAgICogU2V0cyBfaXRlbXNcclxuICAgICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGxpc3Qgb2Ygc2xpZGVzIHB1dCBpbnRvIENhcm91c2VsU2xpZGVEaXJlY3RpdmVzLlxyXG4gICAgICAgKi9cclxuICAgIHNldEl0ZW1zKGNvbnRlbnQ6IENhcm91c2VsU2xpZGVEaXJlY3RpdmVbXSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2xpZGVzRGF0YSB1c2luZyB0aGlzLl9pdGVtc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9kZWZpbmVTbGlkZXNEYXRhO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGN1cnJlbnQgY2xhc3NlcyBmb3Igc2xpZGVcclxuICAgICAqIEBwYXJhbSBzbGlkZSBTbGlkZSBvZiBjYXJvdXNlbFxyXG4gICAgICogQHJldHVybnMgb2JqZWN0IHdpdGggbmFtZXMgb2YgY3NzLWNsYXNzZXMgd2hpY2ggYXJlIGtleXMgYW5kIHRydWUvZmFsc2UgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIHNldEN1clNsaWRlQ2xhc3NlcyhzbGlkZTogU2xpZGVNb2RlbCk6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBib29sZWFuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICAgKiBPcGVyYXRvcnMgdG8gY2FsY3VsYXRlIHJpZ2h0LXRvLWxlZnQgYW5kIGxlZnQtdG8tcmlnaHQuXHJcbiAgICAgICAqIEBwYXJhbSBhIC0gVGhlIGxlZnQgc2lkZSBvcGVyYW5kLlxyXG4gICAgICAgKiBAcGFyYW0gbyAtIFRoZSBvcGVyYXRvci5cclxuICAgICAgICogQHBhcmFtIGIgLSBUaGUgcmlnaHQgc2lkZSBvcGVyYW5kLlxyXG4gICAgICAgKiBAcmV0dXJucyB0cnVlL2ZhbHNlIG1lYW5pbmcgcmlnaHQtdG8tbGVmdCBvciBsZWZ0LXRvLXJpZ2h0XHJcbiAgICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfb3A7XHJcbiAgICAvKipcclxuICAgICAgICogVHJpZ2dlcnMgYSBwdWJsaWMgZXZlbnQuXHJcbiAgICAgICAqIEB0b2RvIFJlbW92ZSBgc3RhdHVzYCwgYHJlbGF0ZWRUYXJnZXRgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZXZlbnQgZGF0YS5cclxuICAgICAgICogQHBhcmFtIG5hbWVzcGFjZSBUaGUgZXZlbnQgbmFtZXNwYWNlLlxyXG4gICAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXHJcbiAgICAgICAqIEBwYXJhbSBlbnRlciBJbmRpY2F0ZXMgaWYgdGhlIGNhbGwgZW50ZXJzIHRoZSBzcGVjaWZpZWQgc3RhdGUgb3Igbm90LlxyXG4gICAgICAgKi9cclxuICAgIHByaXZhdGUgX3RyaWdnZXI7XHJcbiAgICAvKipcclxuICAgICAqIEVudGVycyBhIHN0YXRlLlxyXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZW50ZXIobmFtZTogc3RyaW5nKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICAgKiBMZWF2ZXMgYSBzdGF0ZS5cclxuICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cclxuICAgICAgICovXHJcbiAgICBsZWF2ZShuYW1lOiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBvciBzdGF0ZS5cclxuICAgICAgICogQHBhcmFtIG9iamVjdCAtIFRoZSBldmVudCBvciBzdGF0ZSB0byByZWdpc3Rlci5cclxuICAgICAgICovXHJcbiAgICByZWdpc3RlcihvYmplY3Q6IGFueSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAgICogU3VwcHJlc3NlcyBldmVudHMuXHJcbiAgICAgICAqIEBwYXJhbSBldmVudHMgVGhlIGV2ZW50cyB0byBzdXBwcmVzcy5cclxuICAgICAgICovXHJcbiAgICBwcml2YXRlIF9zdXBwcmVzcztcclxuICAgIC8qKlxyXG4gICAgICAgKiBSZWxlYXNlcyBzdXBwcmVzc2VkIGV2ZW50cy5cclxuICAgICAgICogQHBhcmFtIGV2ZW50cyBUaGUgZXZlbnRzIHRvIHJlbGVhc2UuXHJcbiAgICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcmVsZWFzZTtcclxuICAgIC8qKlxyXG4gICAgICAgKiBHZXRzIHVuaWZpZWQgcG9pbnRlciBjb29yZGluYXRlcyBmcm9tIGV2ZW50LlxyXG4gICAgICAgKiBAdG9kbyAjMjYxXHJcbiAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50LlxyXG4gICAgICAgKiBAcmV0dXJucyBPYmplY3QgQ29vcmRzIHdoaWNoIGNvbnRhaW5zIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cclxuICAgICAgICovXHJcbiAgICBwb2ludGVyKGV2ZW50OiBhbnkpOiBDb29yZHM7XHJcbiAgICAvKipcclxuICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXJcclxuICAgICAgICogQHBhcmFtIG51bWJlciBUaGUgaW5wdXQgdG8gYmUgdGVzdGVkXHJcbiAgICAgICAqIEByZXR1cm5zIEFuIGluZGljYXRpb24gaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXHJcbiAgICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaXNOdW1lcmljO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdmFsdWUgaXMgbnVtYmVyIG9yIGJvb2xlYW4gdHlwZVxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBpbnB1dCB0byBiZSB0ZXN0ZWRcclxuICAgICAqIEByZXR1cm5zIEFuIGluZGljYXRpb24gaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyLCBvciBCb29sZWFuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2lzTnVtYmVyT3JCb29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdmFsdWUgaXMgbnVtYmVyIG9yIHN0cmluZyB0eXBlXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxyXG4gICAgICogQHJldHVybnMgQW4gaW5kaWNhdGlvbiBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3IgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXIsIG9yIFN0cmluZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pc051bWJlck9yU3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdmFsdWUgaXMgbnVtYmVyIG9yIHN0cmluZyB0eXBlXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxyXG4gICAgICogQHJldHVybnMgQW4gaW5kaWNhdGlvbiBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3IgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXIsIG9yIFN0cmluZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pc1N0cmluZ09yQm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICAgKiBHZXRzIHRoZSBkaWZmZXJlbmNlIG9mIHR3byB2ZWN0b3JzLlxyXG4gICAgICAgKiBAdG9kbyAjMjYxXHJcbiAgICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gICAgICAgKiBAcGFyYW0gc2Vjb25kLSBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICAgICAgICogQHJldHVybnMgVGhlIGRpZmZlcmVuY2UuXHJcbiAgICAgICAqL1xyXG4gICAgZGlmZmVyZW5jZShmaXJzdDogQ29vcmRzLCBzZWNvbmQ6IENvb3Jkcyk6IENvb3JkcztcclxufVxyXG4iXX0=