import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
var NgxUiLoaderRouterModule_1;
import { __decorate, __metadata, __param } from "tslib";
import { NgModule, Inject, Optional, SkipSelf } from '@angular/core';
import { NavigationCancel, NavigationEnd, NavigationError, NavigationStart, Router, RouterEvent } from '@angular/router';
import { NgxUiLoaderService } from '../core/ngx-ui-loader.service';
import { NGX_UI_LOADER_ROUTER_CONFIG_TOKEN } from './ngx-ui-loader-router-config.token';
import { ROUTER_LOADER_TASK_ID } from '../utils/constants';
import { getExcludeObj, isIgnored } from '../utils/functions';
let NgxUiLoaderRouterModule = NgxUiLoaderRouterModule_1 = class NgxUiLoaderRouterModule {
    /**
     * Constructor
     */
    constructor(parentModule, customConfig, router, loader) {
        if (parentModule) {
            throw new Error('[ngx-ui-loader] - NgxUiLoaderRouterModule is already loaded. It should be imported in the root `AppModule` only!');
        }
        let config = {
            loaderId: loader.getDefaultConfig().masterLoaderId,
            showForeground: true
        };
        this.exclude = getExcludeObj(customConfig);
        if (customConfig) {
            config = Object.assign(Object.assign({}, config), customConfig);
        }
        router.events.subscribe((event) => {
            if (event instanceof NavigationStart) {
                if (!isIgnored(event.url, this.exclude.strs, this.exclude.regExps)) {
                    if (config.showForeground) {
                        loader.startLoader(config.loaderId, ROUTER_LOADER_TASK_ID);
                    }
                    else {
                        loader.startBackgroundLoader(config.loaderId, ROUTER_LOADER_TASK_ID);
                    }
                }
            }
            if (event instanceof NavigationEnd || event instanceof NavigationCancel || event instanceof NavigationError) {
                if (!isIgnored(event.url, this.exclude.strs, this.exclude.regExps)) {
                    if (config.showForeground) {
                        loader.stopLoader(config.loaderId, ROUTER_LOADER_TASK_ID);
                    }
                    else {
                        loader.stopBackgroundLoader(config.loaderId, ROUTER_LOADER_TASK_ID);
                    }
                }
            }
        });
    }
    /**
     * forRoot
     * @returns A module with its provider dependencies
     */
    static forRoot(routerConfig) {
        return {
            ngModule: NgxUiLoaderRouterModule_1,
            providers: [
                {
                    provide: NGX_UI_LOADER_ROUTER_CONFIG_TOKEN,
                    useValue: routerConfig
                }
            ]
        };
    }
};
NgxUiLoaderRouterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxUiLoaderRouterModule });
NgxUiLoaderRouterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxUiLoaderRouterModule_Factory(t) { return new (t || NgxUiLoaderRouterModule)(ɵngcc0.ɵɵinject(NgxUiLoaderRouterModule, 12), ɵngcc0.ɵɵinject(NGX_UI_LOADER_ROUTER_CONFIG_TOKEN, 8), ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(NgxUiLoaderService)); } });
NgxUiLoaderRouterModule.ctorParameters = () => [
    { type: NgxUiLoaderRouterModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NGX_UI_LOADER_ROUTER_CONFIG_TOKEN,] }] },
    { type: Router },
    { type: NgxUiLoaderService }
];
NgxUiLoaderRouterModule = NgxUiLoaderRouterModule_1 = __decorate([ __param(0, Optional()), __param(0, SkipSelf()),
    __param(1, Optional()), __param(1, Inject(NGX_UI_LOADER_ROUTER_CONFIG_TOKEN)),
    __metadata("design:paramtypes", [NgxUiLoaderRouterModule, Object, Router,
        NgxUiLoaderService])
], NgxUiLoaderRouterModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxUiLoaderRouterModule, [{
        type: NgModule,
        args: [{}]
    }], function () { return [{ type: NgxUiLoaderRouterModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NGX_UI_LOADER_ROUTER_CONFIG_TOKEN]
            }] }, { type: ɵngcc1.Router }, { type: NgxUiLoaderService }]; }, null); })();
export { NgxUiLoaderRouterModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXVpLWxvYWRlci1yb3V0ZXIubW9kdWxlLmpzIiwic291cmNlcyI6WyJuZzovbmd4LXVpLWxvYWRlci9saWIvcm91dGVyL25neC11aS1sb2FkZXItcm91dGVyLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFFBQVEsRUFBdUIsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUV6SCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUVuRSxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN4RixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBSTlELElBQWEsdUJBQXVCLCtCQUFwQyxNQUFhLHVCQUF1QjtJQW1CbEM7O09BRUc7SUFDSCxZQUMwQixZQUFxQyxFQUNOLFlBQXFDLEVBQzVGLE1BQWMsRUFDZCxNQUEwQjtRQUUxQixJQUFJLFlBQVksRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLGtIQUFrSCxDQUFDLENBQUM7U0FDckk7UUFFRCxJQUFJLE1BQU0sR0FBNEI7WUFDcEMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLGNBQWM7WUFDbEQsY0FBYyxFQUFFLElBQUk7U0FDckIsQ0FBQztRQUVGLElBQUksQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRTNDLElBQUksWUFBWSxFQUFFO1lBQ2hCLE1BQU0sbUNBQVEsTUFBTSxHQUFLLFlBQVksQ0FBRSxDQUFDO1NBQ3pDO1FBRUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFrQixFQUFFLEVBQUU7WUFDN0MsSUFBSSxLQUFLLFlBQVksZUFBZSxFQUFFO2dCQUNwQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDbEUsSUFBSSxNQUFNLENBQUMsY0FBYyxFQUFFO3dCQUN6QixNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsQ0FBQztxQkFDNUQ7eUJBQU07d0JBQ0wsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUscUJBQXFCLENBQUMsQ0FBQztxQkFDdEU7aUJBQ0Y7YUFDRjtZQUVELElBQUksS0FBSyxZQUFZLGFBQWEsSUFBSSxLQUFLLFlBQVksZ0JBQWdCLElBQUksS0FBSyxZQUFZLGVBQWUsRUFBRTtnQkFDM0csSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ2xFLElBQUksTUFBTSxDQUFDLGNBQWMsRUFBRTt3QkFDekIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLHFCQUFxQixDQUFDLENBQUM7cUJBQzNEO3lCQUFNO3dCQUNMLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLHFCQUFxQixDQUFDLENBQUM7cUJBQ3JFO2lCQUNGO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUE3REQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFxQztRQUNsRCxPQUFPO1lBQ0wsUUFBUSxFQUFFLHlCQUF1QjtZQUNqQyxTQUFTLEVBQUU7Z0JBQ1Q7b0JBQ0UsT0FBTyxFQUFFLGlDQUFpQztvQkFDMUMsUUFBUSxFQUFFLFlBQVk7aUJBQ3ZCO2FBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQztDQWdERjs7MFVBQUE7O1lBMUN5Qyx1QkFBdUIsdUJBQTVELFFBQVEsWUFBSSxRQUFROzRDQUNwQixRQUFRLFlBQUksTUFBTSxTQUFDLGlDQUFpQztZQUM3QyxNQUFNO1lBQ04sa0JBQWtCOztBQTFCakIsdUJBQXVCLDJDQUkvQixLQUxKLFFBQVEsQ0FBQyxFQUFFLENBQUMsakJBQ1QsQ0F1QkMsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsUUFBUSxFQUFFLENBQUE7SUFDdEIsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLGlDQUFpQyxDQUFDLENBQUE7cUNBRGhCLHVCQUF1QixVQUVyRCxNQUFNO1FBQ04sa0JBQWtCO0dBMUJqQix1QkFBdUIsQ0FpRW5DOzs7Ozs7Ozs7Ozs7O3lGQUNEO1NBbEVhLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBJbmplY3QsIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNhbmNlbCwgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvbkVycm9yLCBOYXZpZ2F0aW9uU3RhcnQsIFJvdXRlciwgUm91dGVyRXZlbnQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5pbXBvcnQgeyBOZ3hVaUxvYWRlclNlcnZpY2UgfSBmcm9tICcuLi9jb3JlL25neC11aS1sb2FkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBOZ3hVaUxvYWRlclJvdXRlckNvbmZpZyB9IGZyb20gJy4uL3V0aWxzL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTkdYX1VJX0xPQURFUl9ST1VURVJfQ09ORklHX1RPS0VOIH0gZnJvbSAnLi9uZ3gtdWktbG9hZGVyLXJvdXRlci1jb25maWcudG9rZW4nO1xuaW1wb3J0IHsgUk9VVEVSX0xPQURFUl9UQVNLX0lEIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGdldEV4Y2x1ZGVPYmosIGlzSWdub3JlZCB9IGZyb20gJy4uL3V0aWxzL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBFeGNsdWRlIH0gZnJvbSAnLi4vdXRpbHMvaW50ZXJmYWNlcyc7XG5cbkBOZ01vZHVsZSh7fSlcbmV4cG9ydCBjbGFzcyBOZ3hVaUxvYWRlclJvdXRlck1vZHVsZSB7XG4gIHByaXZhdGUgZXhjbHVkZTogRXhjbHVkZTtcblxuICAvKipcbiAgICogZm9yUm9vdFxuICAgKiBAcmV0dXJucyBBIG1vZHVsZSB3aXRoIGl0cyBwcm92aWRlciBkZXBlbmRlbmNpZXNcbiAgICovXG4gIHN0YXRpYyBmb3JSb290KHJvdXRlckNvbmZpZzogTmd4VWlMb2FkZXJSb3V0ZXJDb25maWcpOiBNb2R1bGVXaXRoUHJvdmlkZXJzPE5neFVpTG9hZGVyUm91dGVyTW9kdWxlPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBOZ3hVaUxvYWRlclJvdXRlck1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogTkdYX1VJX0xPQURFUl9ST1VURVJfQ09ORklHX1RPS0VOLFxuICAgICAgICAgIHVzZVZhbHVlOiByb3V0ZXJDb25maWdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIHBhcmVudE1vZHVsZTogTmd4VWlMb2FkZXJSb3V0ZXJNb2R1bGUsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChOR1hfVUlfTE9BREVSX1JPVVRFUl9DT05GSUdfVE9LRU4pIGN1c3RvbUNvbmZpZzogTmd4VWlMb2FkZXJSb3V0ZXJDb25maWcsXG4gICAgcm91dGVyOiBSb3V0ZXIsXG4gICAgbG9hZGVyOiBOZ3hVaUxvYWRlclNlcnZpY2VcbiAgKSB7XG4gICAgaWYgKHBhcmVudE1vZHVsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbbmd4LXVpLWxvYWRlcl0gLSBOZ3hVaUxvYWRlclJvdXRlck1vZHVsZSBpcyBhbHJlYWR5IGxvYWRlZC4gSXQgc2hvdWxkIGJlIGltcG9ydGVkIGluIHRoZSByb290IGBBcHBNb2R1bGVgIG9ubHkhJyk7XG4gICAgfVxuXG4gICAgbGV0IGNvbmZpZzogTmd4VWlMb2FkZXJSb3V0ZXJDb25maWcgPSB7XG4gICAgICBsb2FkZXJJZDogbG9hZGVyLmdldERlZmF1bHRDb25maWcoKS5tYXN0ZXJMb2FkZXJJZCxcbiAgICAgIHNob3dGb3JlZ3JvdW5kOiB0cnVlXG4gICAgfTtcblxuICAgIHRoaXMuZXhjbHVkZSA9IGdldEV4Y2x1ZGVPYmooY3VzdG9tQ29uZmlnKTtcblxuICAgIGlmIChjdXN0b21Db25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHsgLi4uY29uZmlnLCAuLi5jdXN0b21Db25maWcgfTtcbiAgICB9XG5cbiAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZSgoZXZlbnQ6IFJvdXRlckV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgICAgaWYgKCFpc0lnbm9yZWQoZXZlbnQudXJsLCB0aGlzLmV4Y2x1ZGUuc3RycywgdGhpcy5leGNsdWRlLnJlZ0V4cHMpKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zaG93Rm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgbG9hZGVyLnN0YXJ0TG9hZGVyKGNvbmZpZy5sb2FkZXJJZCwgUk9VVEVSX0xPQURFUl9UQVNLX0lEKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZGVyLnN0YXJ0QmFja2dyb3VuZExvYWRlcihjb25maWcubG9hZGVySWQsIFJPVVRFUl9MT0FERVJfVEFTS19JRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQgfHwgZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uQ2FuY2VsIHx8IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNJZ25vcmVkKGV2ZW50LnVybCwgdGhpcy5leGNsdWRlLnN0cnMsIHRoaXMuZXhjbHVkZS5yZWdFeHBzKSkge1xuICAgICAgICAgIGlmIChjb25maWcuc2hvd0ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgIGxvYWRlci5zdG9wTG9hZGVyKGNvbmZpZy5sb2FkZXJJZCwgUk9VVEVSX0xPQURFUl9UQVNLX0lEKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZGVyLnN0b3BCYWNrZ3JvdW5kTG9hZGVyKGNvbmZpZy5sb2FkZXJJZCwgUk9VVEVSX0xPQURFUl9UQVNLX0lEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIl19